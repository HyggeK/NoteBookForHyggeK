## 内核态和用户态的区别

用户空间：指的就是用户可以操作和访问的空间，这个空间通常存放我们用户自己写的数据等。

内核空间：是系统内核来操作的一块空间，这块空间里面存放系统内核的函数、接口等。

在用户空间下执行，我们把此时运行得程序的这种状态成为用户态，而当这段程序执行在内核的空间执行时，这种状态称为内核态。



## 用户态切换到内核态的三种方式

#### 系统调用

这是用户进程主动要求切换到内核态的一种方式，用户进程通过系统调用申请操作系统提供的服务程序完成工作。

而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，该中断是程序人员自己开发出的一种正常的异常，这个异常具体就是调用int $0x80的汇编指令，这条汇编指令将产生向量为0x80的编程异常。（软中断）

![img](https://img-blog.csdnimg.cn/20190821211215624.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQyMzg3Mg==,size_16,color_FFFFFF,t_70)

#### 异常

当CPU在执行运行在用户态的程序时，发现了某些事件不可知的异常，这是会触发由当前运行进程切换到处理此异常的内核相关程序中，也就到了内核态，比如缺页异常（硬中断）。

#### 外部设备中断

当外围设备完成用户请求的操作之后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条将要执行的指令，转而去执行中断信号的处理程序，如果先执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。

以系统调用函数open为例：简单图示

![img](https://img-blog.csdnimg.cn/2019010521394350.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01vbnN0ZXI3NTU5,size_16,color_FFFFFF,t_70)

（1）用户态：

① 触发0x80中断

②保存当前的运行位置，状态，数据

③将系统调用号保存到eax寄存器中

触发0x80中断 由系统调用函数触发的中断 。实际上在内核中，  触发0x80中断之后才会有上面的两步 。

（2）每一个中断号在内核中都有一个中断处理程序，中断处理程序是被内核调用来响应中断的

​     通过该中断处理程序陷入内核

（3）在内核中：①有系统调用表，用寄存器中的系统调用号对应一个系统调用函数

​             ②通过函数得到执行该系统调用函数会得到一个返回值fd

​             ③将fd的值用eax寄存器带出  

在函数调用时int fd=open（）；open调用完之后才会将eax中的得到的返回值赋给fd，相当于是两个步骤

只有0x80中断才是系统调用中断，类似的还有缺页中断它们所对应的中断号是不同的

注释：在c语言中如何返回返回值：如果返回值小于四个字节通过eax寄存器带出  若在4-8之间用eax和ecx带出  大于8通过生成临时对象或者变量带出