## select、poll、epoll之间的区别

select、poll和epoll是三种实现I/O的机制，本质上他们都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的。

### select

`select`函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。

#### 原理：

进程调用`select`函数会被阻塞，然后内核会轮询检查`select`负责的fd，直到有文件描述符就绪（或超时timeout），`select`函数就会返回。若未超时，当`select`函数返回后，可以通过调用`FD_ISSET`，遍历`fdset`，来找到就绪的描述符后进程被唤醒，处理结束后又继续轮询检查。

```shell
FD_ZERO(fd_set *fdset);              //将set清零使集合中不含任何fd
FD_SET(int fd, fd_set *fdset);       //将fd加入set集合,底层是bitmap有1024个位置
FD_CLR(int fd, fd_set *fdset);       //将fd从set集合中清除 
FD_ISSET(int fd, fd_set *fdset);     //检测fd是否在set集合中，不在则返回0
```

#### select 的缺点

select本质上是通过设置或者轮询检查存放fd标志位的数据结构（`fdset`）来进行下一步处理，这样做带来了一些缺点：

- 单个进程可监视的fd数量是有限的。
  一般来说这个数目和系统内存关系很大，具体数目可以`cat /proc/sys/fs/file-max`察看。
  32位机默认是1024个。64位机默认是2048。
- 采用轮询的方法，效率较低。
  每一次调用`select`都需要将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态。
  当监听的fd数量较多但活跃数（就绪）较少时，`select`仍然需要遍历检查`FD_SETSIZE`个fd，他的时间复杂度为O(n)。
- 需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大

### poll

`poll`有一个“水平触发”的特点，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。

`poll`和`select`在本质上没有什么区别，但他解决了`select`对监听数量有限制这一缺点，在使用`poll`时，可以传入一个自定义大小的结构体数组，不再受限制。但仍存在问题。

- 仍然采用轮询的方式进行fd检查，每次调用都会将数组传入内核空间，不论其是否有意义

### epoll

在linux上，2.4内核前主要是`select`和`poll`，自Linux 2.6内核正式引入`epoll`以来，`epoll`已经成为了目前实现高性能网络服务器的必备技术。

与前两种方式相比，`epoll`并不是采用轮询的方式监听事件，而是触发式。
我们先了解一下`epoll`的函数再讲解它的内部机制。

#### epoll的内部机制和优势

（1）执行epoll_create()函数会在内核创建一颗红黑树rb_node以及就绪链表rdllist(存放已经就绪的文件描述符)，接着用户执行的epoll_ctl()函数将epoll_event结构体拷贝传入内核，内核会在红黑树上添加相应的结点，内核将就绪的文件描述符事件复制到传入的poll_event结构体数组中返回给用户空间，系统调用在返回时采用**mmap**共享存储区，需要拷贝的次数大大减少。由于epoll创建的有关文件描述符的数据结构本身就存在于内核态中。下一次调用epoll系统调用时，**不需要再次拷贝**用户空间所要监听的文件描述符，也不需要重新构建红黑树和就绪链表等相关数据结构，直接**沿用已经存在的数据结构**。

（2）减少了对就绪文件描述符的遍历

select和poll采用轮询的方式来检查文件描述符是否处于就绪状态。并且内核修改用户传进来的fd_set和pollfd结构体的成员的revents值以告知用户有文件描述符就绪，但是用户并不知道有哪些文件描述符处于就绪态，需要遍历查找就绪文件描述符，因此，应用程序索引就绪文件描述符的时间复杂度为O（n）.

而epoll采用回调机制。在调用epoll_ctl时，已经将用户感兴趣的事件传给了内核，内核会维持一个内核事件表，记录用户感兴趣的事件，就绪事件发生时，驱动设备调用回调函数ep_poll_callback()将就绪的fd挂到rdllist上。用户调用epoll_wait时，将rdllist上就绪的文件描述符发送给用户。此时发送给用户的都是就绪的fd。因此，应用程序索引就绪文件描述符的时间复杂度为O（1）。

（3）select和poll只支持LT模式，而**epoll支持高效的ET模式，并且epoll还支持EPOLLONESHOT事件。**

LT模式（电平触发）：LT模式是默认的工作模式，当检测到文件描述符上有事件发生并将此事件通知给应用程序，应用程序可以不立即处理该事件，**下次调用会再次响应应用程序**并通知此事件。

ET模式（边沿触发）：当检测到文件描述符上有事件发生并将此事件通知给应用程序，应用程序必须立即处理该事件，如果没处理或者没处理完，**下次调用不会再响应应用程序**并通知此事件。

ET模式很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高，epoll工作在ET模式的时候，必须使用非阻塞的套接字，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。

即使使用ET模式，一个socket上的某个事件还是可能被触发多次，这在并发程序中就会引发一个问题。比如一个线程在读取完某个socket上的数据开始处理这些数据的时候，而在数据的处理过程中这个socket上又有新数据可读，这时另一个线程被唤醒来处理新数据，于是就出现了两个线程同时操作一个socket的局面。因此需要使用epoll的EPOLLONESHOT事件实现。对于**注册了EPOLLONESHOT事件的文件描述符**，操作系统最多触发其上的一个读、写或异常事件，且**只触发一次**。当一个线程在处理socket时，其它线程是不可能有机会操作该socket的。注册了EPOLLONESHOT事件的socket一旦被某个线程处理完，该线程就应该立即重置这个socket上的EPOLLONESHOT事件，以确保这个socket下次可读时，其EPOLLIN事件可被触发，进而让其它线程有机会处理这个socket。使用EPOLLONESHOT事件能进一步减少可读、可写和异常事件的被触发的次数。

### 总结

以上简单介绍了一下`select`,`poll`,`epoll`，在介绍的过程中也简述了他们之间的差别
相对于`epoll`的触发式，`select、poll`的轮询方式效率低下，但是每种机制都有自己的适用场景，`epoll`并不是在所有场景下都是最好的。
试想这样一个场景，`select`和`epoll`监听的事件数量一样，这些事件大都处于活跃状态，`select`只要通过一次循环就可以找到他们，但是`epoll`则会频繁地调用回调函数，这样做的效率必定是低于一次循环的效率的。
<font color='red'>`epoll`并不适用于活跃事件较多的情况。</font>